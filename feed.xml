<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mijkenator`s blog</title>
  <subtitle>Project Euler examples</subtitle>
  <id>http://mijkenator.github.io</id>
  <link href="http://mijkenator.github.io"/>
  <link href="http://mijkenator.github.io/feed.xml" rel="self"/>
  <updated>2016-12-10T23:15:00+00:00</updated>
  <author>
    <name>Mijkenator</name>
  </author>
  <entry>
    <title>Merge sort - inversions count</title>
    <link rel="alternate" href="http://mijkenator.github.io/2016/12/10/2016-12-10-mergesort-inversion-count/"/>
    <id>http://mijkenator.github.io/2016/12/10/2016-12-10-mergesort-inversion-count/</id>
    <published>2016-12-10T23:15:00+00:00</published>
    <updated>2016-12-11T02:26:38+00:00</updated>
    <author>
      <name>Mijkenator</name>
    </author>
    <summary type="html">In an array, arr = [a0, a1, &amp;hellip;, aN-1] , the elements at indices i and j  (where i &amp;lt; j) form an inversion if aI &amp;gt; aJ. In other words, inverted elements  and  are considered to be &amp;ldquo;out of order&amp;rdquo;. To correct an inversion, we can swap adjacent elements.

</summary>
  </entry>
  <entry>
    <title>Quick sort with erlang, elixir, python</title>
    <link rel="alternate" href="http://mijkenator.github.io/2016/10/17/erlang-elixir-python-quick-sort/"/>
    <id>http://mijkenator.github.io/2016/10/17/erlang-elixir-python-quick-sort/</id>
    <published>2016-10-17T19:25:00+00:00</published>
    <updated>2016-10-17T20:00:22+00:00</updated>
    <author>
      <name>Mijkenator</name>
    </author>
    <summary type="html">Wikipedia article about merge sort algorithm.
Source code examples on Github

</summary>
  </entry>
  <entry>
    <title>Merge sort with erlang, elixir, python</title>
    <link rel="alternate" href="http://mijkenator.github.io/2016/10/11/2016-10-11-erlang-elixir-python-merge-sort-52-html-markdown/"/>
    <id>http://mijkenator.github.io/2016/10/11/2016-10-11-erlang-elixir-python-merge-sort-52-html-markdown/</id>
    <published>2016-10-11T20:34:00+00:00</published>
    <updated>2016-10-17T19:31:57+00:00</updated>
    <author>
      <name>Mijkenator</name>
    </author>
    <summary type="html">Source code examples on Github
Wikipedia article about merge sort algorithm.

</summary>
  </entry>
  <entry>
    <title>Project Euler problem 53</title>
    <link rel="alternate" href="http://mijkenator.github.io/2016/06/06/erlang-python-project-euler-53/"/>
    <id>http://mijkenator.github.io/2016/06/06/erlang-python-project-euler-53/</id>
    <published>2016-06-06T17:41:00+00:00</published>
    <updated>2016-06-06T19:13:09+00:00</updated>
    <author>
      <name>Mijkenator</name>
    </author>
    <summary type="html">Combinatoric selections

There are exactly ten ways of selecting three from five, 12345:


        123, 124, 125, 134, 135, 145, 234, 235, 245, and 345


In combinatorics, we use the notation, C(3,5) = 10.

</summary>
  </entry>
  <entry>
    <title>Project Euler problem 52</title>
    <link rel="alternate" href="http://mijkenator.github.io/2016/06/03/erlang-python-project-euler-52/"/>
    <id>http://mijkenator.github.io/2016/06/03/erlang-python-project-euler-52/</id>
    <published>2016-06-03T19:33:00+00:00</published>
    <updated>2016-06-06T19:13:09+00:00</updated>
    <author>
      <name>Mijkenator</name>
    </author>
    <summary type="html">Permuted multiples

It can be seen that the number, 125874, and its double, 251748, contain exactly the same digits, but in a different order.

Find the smallest positive integer, x, such that 2x, 3x, 4x, 5x, and 6x, contain the same digits.

</summary>
  </entry>
  <entry>
    <title>Project Euler problem 51</title>
    <link rel="alternate" href="http://mijkenator.github.io/2016/05/31/erlang-python-project-euler-51/"/>
    <id>http://mijkenator.github.io/2016/05/31/erlang-python-project-euler-51/</id>
    <published>2016-05-31T20:16:00+00:00</published>
    <updated>2016-06-06T19:13:09+00:00</updated>
    <author>
      <name>Mijkenator</name>
    </author>
    <summary type="html">Prime digit replacements

By replacing the 1st digit of the 2-digit number *3, it turns out that six of the nine possible values: 13, 23, 43, 53, 73, and 83, are all prime.

By replacing the 3rd and 4th digits of 56**3 with the same digit, this 5-digit</summary>
  </entry>
</feed>
